{"version":3,"sources":["components/canvas/index.tsx","components/canvas/variables.ts","App.tsx","reportWebVitals.ts","index.tsx","components/canvas/styles.module.css","styles.module.css"],"names":["canvas","ctx","paddleX","x","y","bricks","dx","dy","Canvas","canvasRef","useRef","useState","level","setLevel","lives","setLives","score","setScore","generateBricks","c","r","status","draw","clearRect","width","height","brickX","brickY","beginPath","rect","fillStyle","fill","closePath","drawBricks","arc","Math","PI","font","fillText","b","brickRowCount","collisionDetection","window","location","reload","requestAnimationFrame","useEffect","current","getContext","addEventListener","e","relativeX","clientX","offsetLeft","paddleWidth","ref","className","classes","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.03535eec.chunk.js","sourcesContent":["import React, {\r\n    useRef,\r\n    useEffect,\r\n    useState\r\n} from 'react';\r\n\r\nimport classes from './styles.module.css';\r\n\r\nimport {\r\n    ballRadius,\r\n    paddleHeight,\r\n    paddleWidth,\r\n    brickRowCount,\r\n    brickColumnCount,\r\n    brickWidth,\r\n    brickHeight,\r\n    brickPadding,\r\n    brickOffsetTop,\r\n    brickOffsetLeft\r\n} from \"./variables\";\r\n\r\ninterface Brick {\r\n    [key:number]: {\r\n        x: number\r\n        y: number\r\n        status: number\r\n    }\r\n}\r\ninterface Bricks {\r\n    [key: number]: Brick\r\n}\r\n\r\nlet canvas: HTMLCanvasElement;\r\nlet ctx: any;\r\nlet paddleX: number;\r\nlet bricks: Bricks  = [];\r\nlet x: number;\r\nlet y: number;\r\nlet dx = 2;\r\nlet dy = -2;\r\n\r\nconst Canvas: React.FunctionComponent = () => {\r\n    let canvasRef = useRef < HTMLCanvasElement > (null);\r\n    let [level, setLevel] = useState<number>(1);\r\n    let [lives, setLives] = useState<number>(3);\r\n    let [score, setScore] = useState<number>(0);\r\n\r\n    const collisionDetection = () => {\r\n        for (let c = 0; c < brickColumnCount; c++) {\r\n            for (let r = 0; r < brickRowCount; r++) {\r\n                let b = bricks[c][r];\r\n                if (b.status === 1) {\r\n                    if (\r\n                        x > b.x &&\r\n                        x < b.x + brickWidth &&\r\n                        y > b.y &&\r\n                        y < b.y + brickHeight\r\n                    ) {\r\n                        dy = -dy;\r\n                        b.status = 0;\r\n                        setScore(++score);\r\n                        if (score === brickRowCount * brickColumnCount * level) {\r\n                            x = canvas.width / 2;\r\n                            y = canvas.height - 30;\r\n                            setLevel(++level);\r\n                            generateBricks();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const drawBall = () => {\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    };\r\n\r\n    const drawPaddle = () => {\r\n        ctx.beginPath();\r\n        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    };\r\n\r\n    const generateBricks = () => {\r\n        for (let c = 0; c < brickColumnCount; c++) {\r\n            bricks[c] = [];\r\n            for (let r = 0; r < brickRowCount; r++) {\r\n                bricks[c][r] = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    status: 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    const drawBricks = () => {\r\n        for (let c = 0; c < brickColumnCount; c++) {\r\n            for (let r = 0; r < brickRowCount; r++) {\r\n                if (bricks[c][r].status === 1) {\r\n                    let brickX = r * (brickWidth + brickPadding) + brickOffsetLeft;\r\n                    let brickY = c * (brickHeight + brickPadding) + brickOffsetTop;\r\n                    bricks[c][r].x = brickX;\r\n                    bricks[c][r].y = brickY;\r\n                    ctx.beginPath();\r\n                    ctx.rect(brickX, brickY, brickWidth, brickHeight);\r\n                    ctx.fillStyle = \"#000000\";\r\n                    ctx.fill();\r\n                    ctx.closePath();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const drawScore = () => {\r\n        ctx.font = \"16px Roboto\";\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.fillText(\"Score: \" + score, 8, 20);\r\n    }\r\n\r\n    const drawLevel = ()=> {\r\n        ctx.font = \"16px Roboto\";\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.fillText(\"Level: \" + level, 130, 20);\r\n    };\r\n\r\n    const drawLives = () => {\r\n        ctx.font = \"16px Roboto\";\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.fillText(\"Lives: \" + lives, canvas.width - 65, 20);\r\n    };\r\n\r\n    const draw = () => {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        drawBricks();\r\n        drawBall();\r\n        drawPaddle();\r\n        drawScore();\r\n        drawLevel();\r\n        drawLives();\r\n        collisionDetection();\r\n        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {\r\n            dx = -dx;\r\n        }\r\n        if (y + dy < ballRadius) {\r\n            dy = -dy;\r\n        } else if (y + dy > canvas.height - ballRadius) {\r\n            if (x > paddleX && x < paddleX + paddleWidth) {\r\n                dy = -dy;\r\n            } else {\r\n                setLives(--lives);\r\n                if (!lives) {\r\n                    window.location.reload();\r\n                } else {\r\n                    x = canvas.width / 2;\r\n                    y = canvas.height - 30;\r\n                    paddleX = (canvas.width - paddleWidth) / 2;\r\n                }\r\n            }\r\n        }\r\n        x += dx;\r\n        y += dy;\r\n        requestAnimationFrame(draw);\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (canvasRef.current) {\r\n            canvas = canvasRef.current;\r\n            ctx = canvas.getContext('2d');\r\n        }\r\n            x = canvas.width / 2;\r\n            y = canvas.height - 30;\r\n            window.addEventListener(\"mousemove\", e => {\r\n                let relativeX = e.clientX - canvas.offsetLeft;\r\n                if (relativeX > 0 && relativeX < canvas.width) {\r\n                    paddleX = relativeX - paddleWidth / 2;\r\n                }\r\n            });\r\n            generateBricks();\r\n            draw();\r\n        },[]);\r\n\r\n    return <canvas ref={canvasRef} width='300px' height='500px' className={classes.Canvas} /> ;\r\n}\r\n\r\nexport default Canvas;","export const ballRadius = 10;\r\nexport const brickRowCount = 3;\r\nexport const brickColumnCount = 3;\r\nexport const brickWidth = 75;\r\nexport const brickHeight = 20;\r\nexport const brickPadding = 10;\r\nexport const brickOffsetTop = 30;\r\nexport const brickOffsetLeft = 30;\r\nexport const paddleHeight = 10;\r\nexport const paddleWidth = 75;","// LIBs\nimport React from 'react';\n\n// Componenst\nimport Canvas from './components/canvas';\n\nimport classes from './styles.module.css';\nconst App = () => {\n  return (\n    <div className={classes.App}>\n      <Canvas/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Canvas\":\"styles_Canvas__1GxfA\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"styles_App__3xpzS\"};"],"sourceRoot":""}